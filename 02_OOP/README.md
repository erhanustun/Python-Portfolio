# Object-Oriented Programming (OOP) in Python

What is Object-Oriented Programming?

Object-Oriented Programming (OOP) is a programming approach based on the concepts of classes and objects. The goal of this approach is to divide the required program into smaller parts, making it manageable and reusable. Each small part has its own properties, data, and information on how it will communicate with other small parts.

In OOP, programs are designed to enable objects to interact with each other. We model the complexity of real life in a way that computers can understand. Modeling is a method that humans have used since ancient times to solve problems. Instead of trying to visualize and solve a large problem in its entirety in your mind, you can observe the appearance, behavior, or, in some cases, the responses of the target system on the model or models you create.

With Object-Oriented Programming, we model everything we want to do in a way that the computer can understand and transfer it as an “object.” In this way, we make the objects that are valid for us in real life understandable to computers. Of course, this is within the capabilities provided by the programming language used. This creates a language-independent agreement, a philosophy, between the coder and the computer. Now, whatever the “car” object means to us, it means the same to the computer.

Why Object-Oriented Programming?
Object-Oriented Programming (OOP) is a fast and easy-to-implement approach.
OOP provides a clear structure for programs.
OOP implements the "Don't Recurse" principle, making code easier to maintain, organize, and debug.
OOP enables the creation of reusable applications with less code and shorter development time.
OOP provides extensibility by adding new features to the framework later.
OOP enables models of problems based on real-world operations.

## Key OOP Principles
- **Encapsulation** → Grouping data and methods inside classes, protecting internal state.  
- **Inheritance** → Reusing and extending functionality from existing classes.  
- **Polymorphism** → Using a single interface with different underlying data types.  
- **Abstraction** → Hiding unnecessary details and exposing only relevant functionality.  

---

## Files in this folder

### `bank_account.py`
- Demonstrates **encapsulation** and **dunder methods** (`__str__`, `__eq__`).  
- Example operations: deposit, withdraw, balance check.  

### `shapes_inheritance.py`
- Implements **inheritance** with `Shape`, `Circle`, and `Rectangle`.  
- Shows **method overriding** and **polymorphism**.  

### `employee_manager.py`
- Demonstrates **composition**, **class methods**, and **static methods**.  
- Example: managing a team of employees under a manager.  

---
